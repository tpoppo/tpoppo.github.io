<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>An overview of Gradient Boosting Tree | Lorenzo Rossi</title> <meta name="author" content="Lorenzo Rossi"> <meta name="description" content="An overview of Gradient Boosting Tree"> <meta name="keywords" content="academic-website, portfolio-website, machine-learning, ml"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700%7CRoboto+Slab:100,300,400,500,700%7CMaterial+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%8C%A8&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://tpoppo.github.io/blog/2023/gbt/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">{
      "title": "An overview of Gradient Boosting Tree",
      "description": "An overview of Gradient Boosting Tree",
      "published": "February 1, 2023",
      "authors": [
        {
          "author": "Lorenzo Rossi",
          "authorURL": "../../../",
          "affiliations": [
            {
              "name": "ETH Zürich",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Lorenzo </span>Rossi</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">Home</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>An overview of Gradient Boosting Tree</h1> <p>An overview of Gradient Boosting Tree</p> </d-title> <d-byline></d-byline> <d-article> <h2 id="introduction">Introduction</h2> <p>Gradient boosting tree is one of the most powerful and used algorithms for machine learning, especially with tabular data, and many top Kaggle solutions often use it. This post tries to explain the tricks and methods used by the most relevant works in this space.</p> <p>Formally, we would like to solve the classical supervised classification or regression problem: Given a loss function \(L(y, \hat{y})\), we would like to find a function \(F(x)\) that minimize the given loss in the data distribution \(D\): \begin{equation} \underset{F}{\operatorname{argmin}} {\mathop{\mathbb{E}}_{(x, y) \sim D}{L(y, F(x))}} \end{equation}</p> <p>The main idea of boosting is to create \(F\) as a linear sum of weak and simple models \(h\) (in the case of gradient boosting trees, they are decision trees). Therefore: \begin{equation} F(x) = \sum_{i=1}^{m}{h_{i}(x)} \end{equation}</p> <h2 id="training">Training</h2> <p>Given a training set \({(x_1, y_1), ..., (x_n, y_n)}\), the boosting method tries to greedily pick the next best weak model \(h\). \begin{equation} F_{m+1}(x) = F_m(x) + \underset{h_m}{\operatorname{argmin}} \sum_{i=1}^{n}{L(y_i, F_m(x_i)+h_m(x_i))} \end{equation}</p> <p>This problem is generally intractable. Hence, we approximate the optimization using multiple gradient steps, which could be the gradient descent or Newton’s method. For instance, in the case of gradient descent, the formula becomes:</p> <p>\begin{equation} \underset{h_m}{\operatorname{argmin}} \sum_{i=1}^{n}{L(y_i, F_m(x_i)+h_m(x_i))} <br> \end{equation} \begin{equation} \approx \underset{h_m}{\operatorname{argmin}} \sum_{i=1}^{n}{L(y_i, F_m(x_i)) + \nabla L(y_i, F_m(x_i)) h_m(x_i)} <br> \end{equation} \begin{equation} \approx \underset{h_m}{\operatorname{argmin}} \sum_{i=1}^{n}{\nabla L(y_i, F_m(x_i)) h_m(x_i)} \end{equation}</p> <p>Consequently, \(h_m(x)\) should be close to \(-\nabla L(y_i, F_m(x_i))\). So one of the possible approaches is to train the decision tree on \((x_1, \nabla L(y_1, F_m(x_1)))\), \((x_2, \nabla L(y_2, F_m(x_2)))\), …, \((x_n, \nabla L(y_n, F_m(x_n)))\) using the mean squared error.</p> <h2 id="novel-methods">Novel methods</h2> <p>In this section, we compare the different implementations of gradient boosting trees and other novel improvements.</p> <h3 id="xgboost-a-scalable-tree-boosting-system-">XGBoost: A Scalable Tree Boosting System <d-cite key="chen2016xgboost"></d-cite> </h3> <p>Firstly, they used two common regularization methods which are:</p> <ol> <li> <strong>Shrinkage scales</strong>, which means that the newly added decision tree \(h_m\) is multiplied by a factor \(\gamma\) smaller than 1, similar to gradient descent. This technique reduces the influence of each tree.</li> <li> <strong>Column subsampling</strong>, which is a method used in Random Forest, reduces both overfitting and improves training performance.</li> </ol> <p>One of the most important contributions of this work is an approximate algorithm to find the best split. While the basic exact algorithm would try \(O(NK)\) splits with \(N\) samples and \(K\) features, the approximate algorithm tries to map the continuous features into buckets. To solve this mapping problem, this work also proposed a new weighted quantile sketch with provable theoretical guarantees.</p> <p>Another significant contribution of this work is the <strong>sparsity-aware split finding</strong>. In tabular datasets is quite common to have very sparse features (missing features), thus, when splitting the algorithm must decide also whether the missing values should go to the left or the right leaf. Therefore, the splitting algorithm should select (a feature, bucket, and default branch). This method allows us to speed up the training step when there are many missing values.</p> <h3 id="lightgbm-a-highly-efficient-gradient-boosting-decision-tree-">LightGBM: A Highly Efficient Gradient Boosting Decision Tree <d-cite key="ke2017lightgbm"></d-cite> </h3> <p>The main aim of LightGBM is to efficiently work when the feature dimension is high, and the data size is large. Similar to XGBoost, this method uses the histogram-based algorithm for splitting.</p> <p>This work proposed two methods: <strong>Gradient-based One-Side Sampling</strong> (GOSS) and <strong>Exclusive Feature Bundling</strong> (EFB) to improve the training performance without hurting the accuracy of the model.</p> <p>The first one, <strong>Gradient-based One-Side Sampling</strong>, notices that samples with a large gradient are more informative, while the smaller ones are less useful. However, only discarding small gradients is harmful, as this also changes the data distribution. Thus, this method keeps all the large ones and performs random sampling on the small ones. Therefore, it first sorts by the absolute value of the gradients, then it picks the top \(a*100\%\) samples and an additional \(b*100\%\) of the instances randomly from the rest of the dataset. Finally, it amplifies the small gradients by a factor of \(\frac{1-a}{b}\). Consequently, the more difficult samples are more important while not changing too much the data distribution.</p> <p>The second method proposed is called <strong>Exclusive Feature Bundling</strong>, which aims to reduce the number of used features. The main idea of this approach is to group exclusive features into <em>exclusive feature bundles</em>, e.g. features that never take nonzero values simultaneously. However, it can be shown that the problem of partitioning features into the smallest number of exclusive bundles is NP-hard, as it is possible to reduce the graph coloring problem to it, which is known to be NP-hard. Thus, an approximate algorithm is used, additionally, it also allows a small <em>conflict factor</em> \(\gamma\) for non-exclusive samples. To merge a bundle of exclusive features, each feature is mapped using different ranges into a bundle feature e.g. if features \(A\), \(B\) are exclusive features, then feature \(A\) is mapped to \([0, 10)\) and features \(B\) to \([10,20)\). In this way, it reduces the number of features in an almost lossless way.</p> <h3 id="catboost-gradient-boosting-with-categorical-features-support-">CatBoost: gradient boosting with categorical features support <d-cite key="prokhorenkova2018catboost"></d-cite><d-cite key="dorogush2018catboost"></d-cite> </h3> <p>CatBoost mostly focuses on how to handle categorical features and solves the gradient bias problem.</p> <p>Let’s first consider how it is possible to handle categorical features:</p> <ol> <li> <strong>One-hot encoder</strong>: converts each categorical feature into 0-1 features for each possible value. However, this method increases the number of features and cannot handle categories with high cardinality.</li> <li> <strong>Greedy TS (target statistic)</strong>: estimates \(\hat{x}_k^i = {\mathop{\mathbb{E}}}[y \mid x^i=x_k^i]\), which categorical feature \(i\) and the \(k\)-th training sample. The prior weight \(p\), which is generally the average across the entire dataset, is mostly useful with low-frequency features. To choose the strength of the prior a smoothing factor \(a\) is used, so the larger the smoothing factor the most important the prior becomes. \begin{equation} \hat{x}_k^i = \frac{a p+\sum_{j=1}^{n}{[x^i_j=x^i_k]y_j}}{a+\sum_{j=1}^{n}{[x^i_j=x^i_k]}} \end{equation} It is worth noting that this approach is target leakage, which may affect the generalization error of the model.</li> <li> <strong>Holdout TS</strong>: first split the dataset into two partitions. The first one is used to compute the Greedy TS, while the latter is used for training. Therefore, this method reduces the amount of data used for training.</li> <li> <strong>Leave-one-out TS</strong>: computes the TS on everything, but the specific sample. However, this approach does not prevent target leakage.</li> <li> <strong>Ordered TS</strong>: which is the method proposed in CatBoost, computes apply the greedy TS only using the already preprocessed samples.</li> </ol> <p>Another issue that CatBoost tries to tackle is the gradient bias, which means that \(g^t(x_k, y_k)\mid x_k\) is shifted from the distribution \(g^t(x, y)\mid x\) because \((x_k, y_k)\) were already used to train \(F^t\). To solve this problem, CatBoost proposed to change how the values are assigned to each leaf while keeping the same splitting process. Therefore, firstly, the model selects the best splits, as in the previous methods, but, then it assigns the leaf values differently.</p> <p>The original algorithm would assign the values in the following way: \begin{equation} leafValue = \frac{\sum_{i=0}^{n}{g_i}}{n} \end{equation} , where \(g_i\) is the gradient with respect to the \(i\)-th sample.</p> <p>In the new method, every time a new tree is added, \(n\) trees are training, in particular, the \(i\)-th tree is trained on the first \(i\) samples, so it can then compute the gradient on the \(i\)-th sample \(g_i\) using the \(i\)-th model to obtain an unbiased estimate. However, this method is \(O(n^2)\) and has a high variance. The latter can be easily mitigated by repeating this step \(s\) times to reduce the final variance, while the first problem can be solved by computing only every power of 2. Therefore, the complexity is going to be \(2^1+2^3+...+2^{\lceil \log{n} \rceil} &lt; 4n\), which is linear in \(n\). Hence, the final complexity becomes \(O(ns)\).</p> <p>Finally, Catboost introduced another trick to make the base predictors faster, the oblivious trees. All these trees have the same splitting criterion at each level of the tree. Therefore, they are symmetric and less prone to overfitting. Additionally, it can encode the leaf values in an array with size \(2^d\), where \(d\) is the depth of the tree.</p> <p>CatBoost also implements various bootstrapping methods:</p> <ol> <li>Subsampling: means that at every iteration a random subsample is picked and used for training.</li> <li>Bayesian bootstrapping: means that every sample is trained with a weight $w_i$, based on a specific algorithm (for more information <d-cite key="rubin1981bayesian"></d-cite>)</li> </ol> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/2023-02-01-gbt.bib"></d-bibliography> </div> <footer class="fixed-bottom"> <div class="container mt-0"> 2023 Lorenzo Rossi. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>